# 开放-封闭原则 (Open Closed Principle，OCP）

开放-封闭原则（OCP）是最重要的一条原则。软件实体（类、模块、函数）等应该是`可扩展`的，但是`不可修改`的。

开闭原则的含义是：当应用的需求改变时，在**不修改软件实体的源代码或者二进制代码**的前提下，可以扩展模块的功能，使其满足新的需求。

## 开闭原则的作用

1. 对软件测试的影响
   软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。
2. 可以提高代码的可复用性
   粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。
3. 可以提高软件的可维护性
   遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。

## 设计模式中的最少知识原则

- 发布-订阅模式
  发布-订阅模式用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不需要进行任何修改；同样当发布者需要改变时，也不会影响到之前的订阅者。

- 模板方法模式
  模板方法是一种典型的通过封装变化来提高系统扩展性的设计模式。在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽出来放到父类的模板方法里面；而子类的方法具体怎么实现则是可变的，于是把这部分变化的逻辑封装到子类中。通过增加新的子类，便能给系统增加系统新的功能，并不需要改动抽象父类以及其他的子类，这也是符合开发-封闭原则的。

- 策略模式
  策略模式和模板方法模式是一对竞争者。在大多数情况下，它们可以相互替换使用。模板方法模式基于继承的思想，而策略模式则偏重于组合和委托。
  策略模式将各种算法都封装成单独的策略类，这些策略类可以被交换使用。策略和使用策略的客户代码可以分别独立进行修改而互不影响。我们增加一个新的策略类也非常方便，完全不用修改之前的代码。

- 代理模式
  拿预加载图片举例，我们现在已有一个给图片设置 src 的函数 myImage，当我们想为它增加图片预加载功能时，一种做法是改动 myImage 函数内部的代码，更好的做法是提供一个代理函数 proxyMyImage，代理函数负责图片预加载，在图片预加载完成之后，再将请求转交给原来的 myImage 函数，myImage 函数在这个过程中不需要任何改动。
  预加载图片的功能和给图片设置 src 的功能被隔离在两个函数里，它们可以单独改变而互不影响。myImage 不知晓代理的存在，它可以继续专注于自己的职责---给图片设置 src。

- 职责链模式
  一个例子，把一个巨大的订单函数分别拆成了 500 元订单、200 元订单以及普通订单的 3 个函数。这 3 个函数通过职责链连接在一起，客户的请求会在这条链条里面依次传递：

## 实现方式

1、用对象的多态性消除条件分支
2、放置挂钩（hook）分离变化
